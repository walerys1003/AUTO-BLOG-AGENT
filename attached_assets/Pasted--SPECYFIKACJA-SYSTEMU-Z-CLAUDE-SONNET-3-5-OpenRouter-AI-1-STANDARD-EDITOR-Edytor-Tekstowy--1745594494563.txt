ğŸ“ SPECYFIKACJA SYSTEMU Z CLAUDE SONNET 3.5 (OpenRouter AI)
1ï¸âƒ£ STANDARD EDITOR â€“ Edytor Tekstowy (WYSIWYG)
ğŸ“‹ GÅ‚Ã³wne Funkcje:
Edycja tekstu w trybie WYSIWYG.

PodglÄ…d HTML/Markdown.

Zapis szkicu i publikacja treÅ›ci.

Autosave co 2 minuty (lub inny interwaÅ‚).

Wersjonowanie â€“ zapis historii zmian.

Analiza SEO: sÅ‚owa kluczowe, dÅ‚ugoÅ›Ä‡, optymalizacja.

âš™ï¸ Backend â€“ Flask (Python) â€“ API dla Edytora:
GET /editor-content/{id}

POST /editor-content/save

POST /editor-content/publish

GET /editor-content/history/{id} â€“ zwraca historiÄ™ wersji.

POST /editor-content/seo-analyze

Input: { "content": "..." }

Output: { "keywords": [...], "readability_score": ..., "length": ... }

ğŸ› ï¸ Kod: Autosave + Wersjonowanie
python
Kopiuj
Edytuj
import datetime

database = {}
history = {}

@app.route('/editor-content/autosave', methods=['POST'])
def autosave_content():
    data = request.get_json()
    data['last_saved'] = datetime.datetime.now().isoformat()
    database[data['id']] = data
    
    # Dodaj wersjÄ™ do historii
    history.setdefault(data['id'], []).append({
        'timestamp': data['last_saved'],
        'content': data['content']
    })
    
    return jsonify({'success': True, 'message': 'Autosaved successfully'})

@app.route('/editor-content/history/<string:content_id>', methods=['GET'])
def get_history(content_id):
    versions = history.get(content_id, [])
    return jsonify({'history': versions})
2ï¸âƒ£ DYNAMIC GENERATION â€“ Integracja z Claude Sonnet 3.5 (OpenRouter)
ğŸ“‹ Funkcje:
Generacja treÅ›ci paragraf po paragrafie.

WybÃ³r stylu (blogowy, techniczny, kreatywny, formalny).

Dynamiczne podpowiedzi AI (tytuÅ‚y, Å›rÃ³dtytuÅ‚y).

Automatyczna analiza spÃ³jnoÅ›ci treÅ›ci.

âš™ï¸ Backend â€“ Flask + OpenRouter AI API (Claude Sonnet 3.5):
Endpointy REST API:
POST /generate/paragraph

POST /generate/title-suggestions

POST /generate/outline

ğŸ§  PrzykÅ‚ad Integracji z OpenRouter API:
python
Kopiuj
Edytuj
import requests
from flask import Flask, request, jsonify

app = Flask(__name__)
openrouter_api_key = 'YOUR_OPENROUTER_API_KEY'

headers = {
    'Authorization': f'Bearer {openrouter_api_key}',
    'Content-Type': 'application/json'
}

@app.route('/generate/paragraph', methods=['POST'])
def generate_paragraph():
    data = request.get_json()
    topic = data['topic']
    content = data['current_content']
    style = data.get('style', 'neutral')

    prompt = f"Topic: {topic}\nStyle: {style}\nContent so far:\n{content}\nContinue writing the next paragraph:"

    payload = {
        "model": "anthropic/claude-3-sonnet",
        "messages": [{"role": "user", "content": prompt}],
        "max_tokens": 200,
        "temperature": 0.7
    }

    response = requests.post('https://openrouter.ai/api/v1/chat/completions', headers=headers, json=payload)
    response_data = response.json()
    next_paragraph = response_data['choices'][0]['message']['content']

    return jsonify({'next_paragraph': next_paragraph})

@app.route('/generate/title-suggestions', methods=['POST'])
def generate_titles():
    data = request.get_json()
    topic = data['topic']

    prompt = f"Suggest 5 catchy titles for an article about: {topic}"

    payload = {
        "model": "anthropic/claude-3-sonnet",
        "messages": [{"role": "user", "content": prompt}],
        "max_tokens": 100,
        "temperature": 0.8
    }

    response = requests.post('https://openrouter.ai/api/v1/chat/completions', headers=headers, json=payload)
    titles = response.json()['choices'][0]['message']['content']

    return jsonify({'titles': titles.strip().split("\n")})
3ï¸âƒ£ Schemat Stron:
/standard-editor
Edytor WYSIWYG + HTML.

Przycisk Zapisz, Opublikuj, Autosave info.

Panel SEO: keywords, dÅ‚ugoÅ›Ä‡, czytelnoÅ›Ä‡.

Historia wersji (lista zapisÃ³w).

/content-generator
Pole: Temat treÅ›ci, wybÃ³r stylu (dropdown).

Przycisk: Rozpocznij generacjÄ™.

Sekcja paragrafÃ³w: paragraf 1, paragraf 2... (dynamicznie).

Przycisk Generuj dalej.

Podpowiedzi AI: ÅšrÃ³dtytuÅ‚y, nagÅ‚Ã³wki, call to action.

ğŸ“Š Analiza SEO (Python + prosty algorytm):
python
Kopiuj
Edytuj
from flask import Flask, request, jsonify
from collections import Counter
import re

@app.route('/editor-content/seo-analyze', methods=['POST'])
def seo_analyze():
    data = request.get_json()
    content = data['content']
    words = re.findall(r'\w+', content.lower())
    total_words = len(words)
    keywords = Counter(words).most_common(5)
    return jsonify({
        'keywords': keywords,
        'length': total_words,
        'readability_score': round(206.835 - 1.015 * (total_words/5) - 84.6 * (len(words)/total_words), 2)



ğŸ“ Specyfikacja KomponentÃ³w Edytora i Logiki Generacji (Python)
1ï¸âƒ£ STANDARD EDITOR â€“ Komponent Edytora Tekstowego
ğŸ“‹ Funkcje:
Edycja tekstu w trybie WYSIWYG (What You See Is What You Get).

MoÅ¼liwoÅ›Ä‡ zapisu szkicu i publikacji.

PodglÄ…d treÅ›ci.

Edytor HTML/Markdown opcjonalny.

Funkcja automatycznego zapisu co X minut.

âš™ï¸ Backend â€“ Python (Flask) â€“ API dla Edytora:
Endpointy REST API:
GET /editor-content/{id}

Opis: Pobiera treÅ›Ä‡ szkicu/artykuÅ‚u do edycji.

Zwraca: JSON { "title": "...", "content": "...", "status": "draft/published" }

POST /editor-content/save

Opis: Zapisuje szkic lub aktualizuje istniejÄ…cy.

Input JSON: { "id": "...", "title": "...", "content": "...", "status": "draft" }

Output: { "success": true, "message": "Saved successfully" }

POST /editor-content/publish

Opis: Publikuje treÅ›Ä‡.

Input JSON: { "id": "...", "content": "...", "status": "published" }

Output: { "success": true, "message": "Published successfully" }

ğŸ› ï¸ PrzykÅ‚adowy kod â€“ Flask (Python):
python
Kopiuj
Edytuj
from flask import Flask, request, jsonify

app = Flask(__name__)
# PrzykÅ‚adowa baza danych w postaci sÅ‚ownika
database = {}

@app.route('/editor-content/<string:content_id>', methods=['GET'])
def get_content(content_id):
    content = database.get(content_id)
    if content:
        return jsonify(content)
    else:
        return jsonify({'error': 'Content not found'}), 404

@app.route('/editor-content/save', methods=['POST'])
def save_content():
    data = request.get_json()
    database[data['id']] = data
    return jsonify({'success': True, 'message': 'Saved successfully'})

@app.route('/editor-content/publish', methods=['POST'])
def publish_content():
    data = request.get_json()
    data['status'] = 'published'
    database[data['id']] = data
    return jsonify({'success': True, 'message': 'Published successfully'})

if __name__ == '__main__':
    app.run(debug=True)
2ï¸âƒ£ DYNAMIC GENERATION â€“ Logika Generowania TreÅ›ci Paragraf po Paragrafie
ğŸ“‹ Funkcje:
Interaktywne generowanie tekstu AI z podglÄ…dem na Å¼ywo.

KaÅ¼dy paragraf pojawia siÄ™ po klikniÄ™ciu â€Generuj dalejâ€ lub automatycznie.

MoÅ¼liwoÅ›Ä‡ modyfikacji kaÅ¼dego paragrafu.

ğŸ”„ Frontend â€“ Logika Dynamicznej Interakcji:
UÅ¼ytkownik klika â€Generuj pierwszy paragrafâ€ â†’ zapytanie do /generate/paragraph.

Po otrzymaniu paragrafu â†’ wyÅ›wietlenie go w edytorze.

Przycisk â€Generuj kolejnyâ€ powtarza zapytanie, zaktualizowany kontekst to caÅ‚a dotychczasowa treÅ›Ä‡.

UÅ¼ytkownik moÅ¼e dowolnie edytowaÄ‡ treÅ›Ä‡.

3ï¸âƒ£ Schemat Strony Edytora:
/standard-editor
Edytor WYSIWYG

PodglÄ…d HTML

Przycisk â€Zapiszâ€

Przycisk â€Opublikujâ€

4ï¸âƒ£ Schemat Strony Dynamic Generator:
/content-generator
Pole â€Temat treÅ›ciâ€

Przycisk â€Rozpocznij generacjÄ™â€

Sekcja generowanych paragrafÃ³w

Przycisk â€Generuj dalejâ€

Przycisk â€Zapisz treÅ›Ä‡â€

ğŸ“ˆ Zaawansowane Funkcje do RozwaÅ¼enia:
Podpowiedzi AI: dynamiczne sugestie dla uÅ¼ytkownika (np. tytuÅ‚y, Å›rÃ³dtytuÅ‚y).

Stylizacja AI: generowanie treÅ›ci w wybranym stylu (blog, techniczny, emocjonalny).

Wersjonowanie treÅ›ci: historia zmian i moÅ¼liwoÅ›Ä‡ cofania.

Analiza SEO: analiza treÅ›ci pod kÄ…tem sÅ‚Ã³w kluczowych, dÅ‚ugoÅ›ci itp.
    })